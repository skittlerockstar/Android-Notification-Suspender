package com.example.maxverhoeven.notificationsuspender;

import android.app.Notification;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.IBinder;
import android.os.Vibrator;
import android.service.notification.NotificationListenerService;
import android.service.notification.StatusBarNotification;
import android.support.annotation.RequiresApi;
import android.widget.RemoteViews;

/**
 * Requires api 24 because of android bug with reconnection of NotificationListenerService
 * Created by Max Verhoeven on 17-5-2017.
 */
@RequiresApi(api = Build.VERSION_CODES.N)
public class NotificationSuspender extends NotificationListenerService {

    public static final int CANCEL_HEADSUP_ID = 389;

    private Notification mHeadsUpPreventionNotification;
    private NotificationManager mNotificationManager;
    private static NotificationSuspenderManager mNotificationSuspenderManager;

    private Vibrator mVibrationService;
    private RemoteViews mEmptyHeadsUpView;

    private static boolean mIsServiceConnected = false;

    public static boolean isServiceConnected() {
        return mIsServiceConnected;
    }

    public static NotificationSuspenderManager getNotificationSuspenderManager() {
        return mNotificationSuspenderManager;
    }

    /**
     * required empty constructor
     */
    public NotificationSuspender() {
        super();
    }

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
    }


    /**
     * Is called by the system when a notification is posted.
     * calls {@link NotificationSuspenderManager#onPostNotification(StatusBarNotification, RankingMap)}
     * if {@link NotificationSuspenderManager#mSuspendNotifications} is set to true and the notification's id is not that of mHeadsUpPreventionNotification
     * also calls the autoCancelHeadsUpNotification
     *
     * @param sbn
     * @param rankingMap
     */
    @Override
    public void onNotificationPosted(StatusBarNotification sbn, RankingMap rankingMap) {
        if (mNotificationSuspenderManager.isSuspendingNotifications() && sbn.getId() != CANCEL_HEADSUP_ID) {
            mNotificationSuspenderManager.onPostNotification(sbn, rankingMap);
            autoCancelHeadsUpNotification(sbn);
        }
        super.onNotificationPosted(sbn, rankingMap);
    }

    /**
     * this is called when the {@link NotificationListenerService} is connected to the app.
     * Only after this event can the notification suspender feature be used.
     * Sets the initial variables needed for this feature.
     */
    @Override
    public void onListenerConnected() {
        mVibrationService = (Vibrator) getSystemService(VIBRATOR_SERVICE);
        mEmptyHeadsUpView = new RemoteViews(getPackageName(), R.layout.empty_headsup_custom_view); // Empty Headsup Notification
        mHeadsUpPreventionNotification = new Notification.Builder(this)
                .setContentTitle("")
                .setContentText("")
                .setSmallIcon(R.mipmap.ic_launcher)
                .setDefaults(Notification.DEFAULT_LIGHTS)
                .setVibrate(new long[0])
                .setCustomHeadsUpContentView(mEmptyHeadsUpView)
                .setAutoCancel(true)
                .setPriority(Notification.PRIORITY_MAX).build();

        mNotificationSuspenderManager = NotificationSuspenderManager.getInstance(this);
        mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        setPolicy();
        mIsServiceConnected = true;
        super.onListenerConnected();
    }

    /**
     * sets the policy for notifications so that they can be cancelled correctly
     */
    private void setPolicy() {
        NotificationManager.Policy policy = new NotificationManager.Policy(
                NotificationManager.Policy.PRIORITY_CATEGORY_MESSAGES,
                NotificationManager.Policy.PRIORITY_SENDERS_ANY,
                NotificationManager.Policy.PRIORITY_SENDERS_ANY,
                NotificationManager.Policy.SUPPRESSED_EFFECT_SCREEN_OFF);
        mNotificationManager.setNotificationPolicy(policy);
        mNotificationManager.setInterruptionFilter(NotificationManager.INTERRUPTION_FILTER_NONE);
    }


    @Override
    public void onListenerDisconnected() {
        mIsServiceConnected = false;
        super.onListenerDisconnected();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return super.onBind(intent);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }


    /**
     * Cancels the headsup generated by notifications with PRIORITY_HIGH / PRIORITY_MAX because this isn't cancelled by default
     * this is done by generating a custom empty heads up notification that hides the first one.
     *
     * @param sbn
     */
    private void autoCancelHeadsUpNotification(StatusBarNotification sbn) {
        if (sbn.getNotification().priority == Notification.PRIORITY_HIGH || sbn.getNotification().priority == Notification.PRIORITY_MAX) {
            sbn.getNotification().priority = Notification.PRIORITY_LOW;
            setPolicy();
            mNotificationManager.notify(CANCEL_HEADSUP_ID, mHeadsUpPreventionNotification);
            mNotificationManager.cancel(CANCEL_HEADSUP_ID);
        }
    }
}
