package com.example.maxverhoeven.notificationsuspender;

import android.content.BroadcastReceiver;
import android.app.Notification;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.service.notification.NotificationListenerService;
import android.service.notification.StatusBarNotification;
import android.support.annotation.RequiresApi;
import android.util.Log;
import android.widget.RemoteViews;
import android.widget.Toast;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * Requires api 24 because of android bug with reconnection of NotificationListenerService
 * Created by Max Verhoeven on 17-5-2017.
 */
//@RequiresApi(api = Build.VERSION_CODES.N)
public class NotificationSuspender extends NotificationListenerService {

    public static final String BCNLS_NAME = ".NOTIFICATION_LISTENER";
    public static final String EXTRA_KEY =  "COMMAND";
    public static final int COMMAND_DISABLE = 0,
                            COMMAND_ENABLE = 1,
                            COMMAND_REVIVE = 2;

    private Notification mHeadsUpPreventionNotification;
    private NotificationManager mNotificationManager;
    private RemoteViews mEmptyHeadsUpView;

    private Set<StatusBarNotification> mSuspendedNotifications = new HashSet<>();

    private boolean mSuspendNotifications = false;

    private static boolean mIsServiceRunning = false;
    private NotificationReceiver mNSReceiver;

    public static boolean isServiceRunning(){
        return mIsServiceRunning;
    }

    @Override
    public void onNotificationPosted(StatusBarNotification sbn, RankingMap rankingMap) {
        if(mSuspendNotifications && !sbn.getPackageName().equals(getPackageName())){
            mSuspendedNotifications.add(sbn);
            autoCancelHeadsUpNotification(sbn);
            super.cancelNotification(sbn.getKey());
        }
    }

    /**
     * this is called when the {@link NotificationListenerService} is connected to the app.
     * Only after this event can the notification suspender feature be used.
     * Sets the initial variables needed for this feature.
     */
    @Override
    public void onListenerConnected() {
        mNSReceiver = new NotificationReceiver();
        mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        mEmptyHeadsUpView = new RemoteViews(getPackageName(), R.layout.empty_headsup_custom_view); // Empty Headsup Notification
        setNotification();
        setPolicy();
        registerNSReceiver();
        NotificationSuspender.mIsServiceRunning = true;
        NSLogger("Service Connected");
        super.onListenerConnected();
    }

    private void registerNSReceiver() {
        IntentFilter i = new IntentFilter();
        i.addAction(getPackageName()+BCNLS_NAME);
        registerReceiver(mNSReceiver,i);
    }


    private void setNotification() {
        mHeadsUpPreventionNotification = new Notification.Builder(this)
                .setContentTitle("")
                .setContentText("")
                .setSmallIcon(R.mipmap.ic_launcher)
                .setDefaults(Notification.DEFAULT_LIGHTS)
                .setVibrate(new long[0])
                .setCustomHeadsUpContentView(mEmptyHeadsUpView)
                .setAutoCancel(true)
                .setPriority(Notification.PRIORITY_MAX).build();
    }


    /**
     * sets the policy for notifications so that they can be cancelled correctly
     */
    private void setPolicy() {
        NotificationManager.Policy policy = new NotificationManager.Policy(
                NotificationManager.Policy.PRIORITY_CATEGORY_MESSAGES,
                NotificationManager.Policy.PRIORITY_SENDERS_ANY,
                NotificationManager.Policy.PRIORITY_SENDERS_ANY,
                NotificationManager.Policy.SUPPRESSED_EFFECT_SCREEN_OFF);
        mNotificationManager.setNotificationPolicy(policy);
        mNotificationManager.setInterruptionFilter(NotificationManager.INTERRUPTION_FILTER_NONE);
    }


    @Override
    public void onListenerDisconnected() {
        NotificationSuspender.mIsServiceRunning = false;
        NSLogger("Service Disconnected");
        super.onListenerDisconnected();
    }

    /**
     * Cancels the headsup generated by notifications with PRIORITY_HIGH / PRIORITY_MAX because this isn't cancelled by default
     * this is done by generating a custom empty heads up notification that hides the first one.
     *
     * @param sbn
     */
    private void autoCancelHeadsUpNotification(StatusBarNotification sbn) {
        boolean isThisApp = sbn.getPackageName().equals(getPackageName());
        boolean isHighPriority = sbn.getNotification().priority == Notification.PRIORITY_HIGH;
        boolean isMaxPriority = sbn.getNotification().priority == Notification.PRIORITY_MAX;

        if (!isThisApp && ( isHighPriority || isMaxPriority )) {
            int rID = (int) (Math.random()*10000);
            mNotificationManager.notify(rID, mHeadsUpPreventionNotification);
            mNotificationManager.cancel(rID);
        }
    }

    class NotificationReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            NotificationSuspender ns = NotificationSuspender.this;
            NSLogger("Received BC in NS:");
            int intExtra = intent.getIntExtra(EXTRA_KEY, -1);
            switch (intExtra){
                    case COMMAND_ENABLE: ns.suspend(true);
                        break;
                    case COMMAND_DISABLE: ns.suspend(false);
                        break;
                    case COMMAND_REVIVE: ns.revive();
                        break;
            }
        }
    }

    private void revive() {
        mSuspendNotifications = false;
        Iterator<StatusBarNotification> iterator = mSuspendedNotifications.iterator();
        while (iterator.hasNext()){
            reviveNotification(iterator.next());
            iterator.remove();
        }
    }

    private void reviveNotification(StatusBarNotification sbn) {
        if(!sbn.isClearable() || sbn.isOngoing()) return;

        String packageName = sbn.getPackageName();
        int id = sbn.getId();
        Notification notification = sbn.getNotification();

        mNotificationManager.notify(packageName,id,notification);
        NSLogger("Reviving Notification for: "+packageName);
    }

    private void suspend(boolean b) {
        NSLogger("Setting Suspender to:"+String.valueOf(b));
        mSuspendNotifications = b;
    }
    private void NSLogger(String s){
        Log.d("NotificationSuspender: ",s);
    }
}
